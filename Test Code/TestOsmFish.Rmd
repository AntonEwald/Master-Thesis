---
title: "Test Data"
author: "Anton Holm"
date: '2021-12-13'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(loomR)
library(tidyverse)
library(rhdf5)
library(MASS)
library(dbscan)
library(raster)
library(matrixStats)
Sys.setenv(RETICULATE_PYTHON = "C:\\Users\\anton\\PycharmProjects\\HelloWorld\\venv\\Scripts\\python.exe")
library(reticulate)
```

```{r}
################################ For cells ###########################################
#Read data and extract useful information
lfile <- connect(filename = "osmFISH.loom", mode = "r+")
gene_count <- lfile$matrix[,]
gene_names <- lfile$row.attrs$Gene[]
clusters <- lfile$col.attrs$ClusterID[]
x <- lfile$col.attrs$X[]
y <- lfile$col.attrs$Y[]
df <- as.data.frame(gene_count)
colnames(df) <- gene_names
cell_id <- lfile$col.attrs$CellID[]

#Spatial information of different cells
data <- df %>% 
  mutate(CellID = cell_id, Cluster = as.factor(clusters), x = x, y = y) %>% 
  dplyr::select(CellID, Cluster, x, y, everything())

ggplot(data, aes(x = x, y = y, col = Cluster)) + 
  geom_point()
###########################################################################################
```

```{r}
########################################## SSAM ###########################################
#Gaussian kernel width = h
kernel <- function(x, h){
  1/(2*pi*h^2) * exp(-1/2 * x/h^2)
}

#Proportions from SSAM code
pix_per_um <- 15.3846
um_per_pix <- 1/pix_per_um

## Load data of all genes (list of dataframes) ##
genes <- h5ls("osmFISHcoords.hdf5")
gene_names <- genes$name
#Genes as list of df
all_genes_df <- map(gene_names, ~as.data.frame(t(h5read("osmFISHcoords.hdf5", .x))) %>% mutate(gene = .x) %>% 
                      mutate(V1 = V1 * um_per_pix, V2 = V2 * um_per_pix))
#Genes in one df with labels in column 3
genes_coords <- all_genes_df %>% 
  reduce(full_join, by = c("V1", "V2", "gene"))
#list of matrices with coordinates of genes
all_genes_matrix_unscaled <- map(gene_names, ~t(h5read("osmFISHcoords.hdf5", .x)))
all_genes_matrix <- lapply(all_genes_matrix_unscaled, function(x) x*um_per_pix)

## Kernel Density Estimation ##
#Calculate euclidean distance to all k-nearest neighbors (list with each gene-type in the list)
knn_distance <- map(1:39, ~kNNdist(all_genes_matrix[[.x]], k = 50, all = TRUE))
#Apply kernel function
kernel_knn_dist <- map(1:39, ~kernel(knn_distance[[.x]], h = 2.5))
knn_kde <- map(1:39, ~rowSums(kernel_knn_dist[[.x]]))

#2 example plots of the density, first one fewer points, second many points
ggplot(as.data.frame(all_genes_matrix[[1]]), aes(x = V1, y = V2, alpha = knn_kde[[1]])) +
  geom_point()
ggplot(as.data.frame(all_genes_matrix[[2]]), aes(x = V1, y = V2, alpha = knn_kde[[2]])) +
  geom_point()
##


## create vector field ##
# Extract largest x and y coordinate from the genes to create a grid/pixels
x_max <- max(do.call(rbind, lapply(all_genes_matrix, colMaxs))[,1])
y_max <- max(do.call(rbind, lapply(all_genes_matrix, colMaxs))[,2])
max_coord = max(x_max, y_max)
#Create the grid
pixels <- raster(xmn = 0, xmx = max_coord, ymn = 0, ymx = max_coord, res = 10)
#List of df. One df per gene. Df contain coordinates, name, kde value
kde_genes_df <- map(1:39, ~mutate(all_genes_df[[.]], value = knn_kde[[.]]))
#Assign genes to pixels. Sum kde of each gene type up
rast <- map(1:39, ~rasterize(kde_genes_df[[.]][,1:2], pixels, field = kde_genes_df[[.]][4], fun = sum))
#Create Vector Field (list of df)
vec_field <- map(1:39, ~getValues(rast[[.]]) %>% 
                   as.data.frame() %>% 
                   replace(is.na(.), 0))

#Need better way to rename column
for(i in 1:39){
  names(vec_field[[i]])[1] <- gene_names[i]
}

#The complete vectorfield. Each column contains the KDE of every pixel of a gene
full_vec_field <- do.call(cbind.data.frame, vec_field) %>% 
  mutate(total_kde = rowSums(.),
         x = rep(0:(dim(pixels)[2]-1), length.out = n()),
         y = rep(0:(dim(pixels)[1]-1),  each = dim(pixels)[2])) %>% 
  rowid_to_column("PixelID")

#plot of vec field (one plot per gene)
vec_field_plotted <- map(1:39, ~plot(rast[[.]]))
##

full_vec_field %>% 
  ggplot(aes(x = x, y = y)) +
  geom_raster(aes(fill = total_kde))

full_vec_field %>% 
  ggplot(aes(x = x, y = y)) + 
  geom_point(aes(alpha = total_kde))

full_vec_field %>% 
  arrange(desc(total_kde)) %>% 
  slice(1:30000) %>% 
  sample_n(size = 12000) %>% 
  ggplot(aes(x = x, y = y)) + 
  geom_point(size = 0.4, aes(alpha = total_kde))

kde_grid <- full_vec_field %>% 
  dplyr::select(x, y, total_kde) %>% 
  spread(key = x, value = total_kde) %>% 
  dplyr::select(-y) %>% 
  as.matrix()

save(kde_grid, file = "kdematrix.Rdata")

```

```{python}
### Downsamopling using python function
from scipy import ndimage as ndi
import matplotlib.pyplot as plt
from skimage.feature import peak_local_max
from skimage import data, img_as_float


im = r.kde_grid

# image_max is the dilation of im with a 20*20 structuring element
# It is used within peak_local_max function
image_max = ndi.maximum_filter(im, size=0.5, mode='constant')

# Comparison between image_max and im to find the coordinates of local maxima
coordinates = peak_local_max(im, min_distance=1)

# display results
fig, axes = plt.subplots(1, 3, figsize=(8, 3), sharex=True, sharey=True)
ax = axes.ravel()
ax[0].imshow(im, cmap=plt.cm.gray)
ax[0].axis('off')
ax[0].set_title('Original')

ax[1].imshow(image_max, cmap=plt.cm.gray)
ax[1].axis('off')
ax[1].set_title('Maximum filter')

ax[2].imshow(im, cmap=plt.cm.gray)
ax[2].autoscale(False)
ax[2].plot(coordinates[:, 1], coordinates[:, 0], 'r.')
ax[2].axis('off')
ax[2].set_title('Peak local max')

fig.tight_layout()

plt.show()

```

```{r}
as_data_frame(py$coordinates) %>% 
  rename(x = "V1", y = "V2") %>% 
  left_join(full_vec_field, by = c("x", "y")) %>% 
  arrange(desc(total_kde))

full_vec_field %>% 
  filter(x == 318, y == 171)

full_vec_field %>% 
  arrange(desc(total_kde)) %>% 
  dplyr::select(total_kde)
```

I now have the vector field with "vector_field" being a list of df where each df has pixel ID and KDE value of that gene in that pixel.
Next, need to do the downsampling. But first I need to normalize the vector field somehow.


They never use peak_local_max in the source code! Ctrl + F "find_localmax"




Also need to read about Smoothing Splines (See Supervised Learning prints sec 6.1-6.3)