---
title: "DensityEstimation2VaryingCov"
author: "Anton Holm"
date: '2022-03-16'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this method I use 200 nearest neighbor instead of $\epsilon$ neighborhood to evaluate if the estimated mode is close to the true mode or not. That could be why the results differ.

First we generate data from a GMM with 540 gaussians (mimics 540 cells) with a varying variance taken from a uniform distribution between 1 and 6 in both x and y dimensions.
We have on average 250 genes per cell which gives us 135K genes in total. Once again this is a piece of a tissue.

```{r, eval = FALSE}
#### Generates a GMM data sample ####
 # No need to run this code
source("..\\Generate_Data_VaryingCov_Script.R")
gauss_varying_cov <- generate_data_varyingCov(n = 135000, clusters = 540, tissue_x = 600, tissue_y = 900)
 #saveRDS(gauss_varying_cov, file = "GMM_data_varying_cov.rdata")
########################################
```

We then extract the quantitites needed.
We also compute the Adjacency Matrix of the data.

```{r}
GMM_data_VC <- readRDS("GMM_data_varying_cov.rdata")
GMM_coordinates_VC <- GMM_data_VC[[1]]
True_density_VC <- GMM_data_VC[[2]]
True_rank_VC <- rank(GMM_data_VC[[2]])
mu_VC <- GMM_data_VC[[3]]
GMM_sample_VC <- GMM_data_VC[[4]]

#Elements are d_ij
Adjacency_Matrix_VC <- kNNdist(GMM_coordinates_VC, k = 7, all = TRUE)
```

Here are the same density estimators as previously.
```{r}
Density_Vector1_VC <- 1/rowSums(Adjacency_Matrix_VC)
Density_vector2_VC <- 1/(1 + rowSums(Adjacency_Matrix_VC^2))
#### Gaussian Kernel Estimation ####
kernel <- function(x, h){
  1/(2*pi*h^2) * exp(-1/2 * (x/h)^2)
}

#Calculate euclidean distance to all k-nearest neighbors (list with each gene-type in the list)
knn_distance_VC <- kNNdist(GMM_coordinates_VC, k = 50, all = TRUE)

kde_dens_VC <- kernel(knn_distance_VC, h = 2.5) %>% 
  rowSums()
####################################
```



Next we want to find the local maximum density peaks around each true mode of the 540 gaussians in the GMM data. We take a small $\epsilon$-neighborhood around the true mode and chose the gene with the largest estimated density as the estimated cell center (or gaussian mode). In the end, we have a dataframe with 540 estimated modes which are different for each of the 3 different density estimatiors.

```{r}
Estimated_modes1_VC <- matrix(NA, nrow = 540, ncol = 6)
Estimated_modes2_VC <- matrix(NA, nrow = 540, ncol = 6)
Estimated_modes3_VC <- matrix(NA, nrow = 540, ncol = 6)

for (i in 1:540) {
  M <- cbind(1:nrow(GMM_coordinates_VC), apply(GMM_coordinates_VC, MARGIN = 1, FUN = function(x) sqrt(sum((x[]-mu_VC[i,])^2))), Density_Vector1_VC, Density_vector2_VC, kde_dens_VC)
  ordered <- M[order(M[,2]),] %>% .[1:250,] %>% 
    cbind(1:nrow(.))
  Estimated_modes1_VC[i, ] <- ordered[which.max(ordered[,3]), ]
  Estimated_modes2_VC[i, ] <- ordered[which.max(ordered[,4]), ]
  Estimated_modes3_VC[i, ] <- ordered[which.max(ordered[,5]), ]

  print(i)
}
```

```{r}
Final_mode_df_VC <- Estimated_modes1_VC %>% 
  as_tibble() %>% 
  dplyr::select(V1, V2, V6) %>% 
  rename(c("Datapoint ID" = V1, "Distance to mode" = V2, "KNN index" = V6)) %>% 
  mutate(Method = "Inverse Distance") %>% 
  add_row(`Datapoint ID` = Estimated_modes2_VC[, 1], `Distance to mode` = Estimated_modes2_VC[, 2], `KNN index` = Estimated_modes2_VC[, 6], Method = "Stationary Distribution") %>% 
  add_row(`Datapoint ID` = Estimated_modes3_VC[, 1], `Distance to mode` = Estimated_modes3_VC[, 2], `KNN index` = Estimated_modes3_VC[, 6], Method = "KDE") 

 saveRDS(Final_mode_df_VC, file = "Estimated_Modes_vs_True_Data_VC.rdata")
```

All above is ground work
----------------------------------------------------------------------------------------
All Below is Analysis



Now we construct two dataframes. One dataframe containing the coordinates of all the estimated modes and the true modes aswell as the position of the estimated mode in relation to its corresponding true mode. 

It was shown that for the KDE estimator, a proportion of its estimated modes lie far away from the true mode. The second dataframe contains these estimated modes, i.e. a subset of the first dataframe.

```{r}
Estimated_vs_True_VC <- readRDS("Estimated_Modes_vs_True_Data_VC.rdata")

Estimated_Mode_Statistics_VC <- Estimated_vs_True_VC %>% 
    mutate(ID = rep(1:540, 3)) %>% 
  mutate(x = GMM_coordinates_VC[`Datapoint ID`, 1],
         y = GMM_coordinates_VC[`Datapoint ID`, 2],
         mu_x = rep(mu_VC[, 1], 3),
         mu_y = rep(mu_VC[, 2], 3)) %>% 
  mutate(diff_x = x-mu_x,
         diff_y = y-mu_y)

# All points around the second peak of KDE
Far_distance_VC <- Estimated_vs_True_VC %>% 
  mutate(ID = rep(1:540, 3)) %>% 
  filter(`Distance to mode` > 3) 
```


Now we calculate the distribution of the distances between estimated mode to its true mode. Kde has more estimated modes that are close but has several estimated modes that were not good. The mean is smaller for KNN but the sd is larger (almost 2x).

```{r}
#Spatial distribution of estimated modes  
Estimated_vs_True_VC %>% 
  ggplot(aes(x = `KNN index`, col = `Method`)) +
  geom_density() +
  labs(title = "Distribution of which k-NN of true mode is the estimated mode")

#Shows distribution of the distance of estimated mode to the true mode
Estimated_vs_True_VC %>% 
  ggplot(aes(x = `Distance to mode`, col = Method)) +
  geom_density() +
  labs(title = "Distribution of distance to true mode")


mean_sd_above_distribution_VC <- Estimated_vs_True_VC %>% 
  group_by(Method) %>% 
  summarise(mean = mean(`Distance to mode`),
            sd = sd(`Distance to mode`))
```

RGB plot of the estimated modes position towards their true mode
And bias + variance of estimates position
```{r}
# How does estimated modes lie from the perspective of the true modes?
ggplot(Estimated_Mode_Statistics_VC, aes(x = diff_x, y = diff_y, col = Method)) +
  geom_point() +
  labs(title = "Estimated modes position from the perspective of true modes")

ggplot(Estimated_Mode_Statistics_VC, aes(x = diff_x, y = diff_y)) +
  geom_point() +
  facet_grid(~Method)

#Table of bias and standard deviation
Estimated_Mode_Statistics_VC %>% 
  group_by(Method) %>% 
  summarise(x_bias = mean(diff_x), y_bias = mean(diff_y), x_sd = sd(diff_x), y_sd = sd(diff_y))
```


Closest distance of each true mode towards another true mode (only those where estimations were bad)

For the 2 graph methods they cant estimate gaussian nr 72 even though it does not have another cell closer than 34um away. It is the cluster at 250,250 and it does not have any other points close to it (see data visual at the start). KDE Can but fails on others instead.

Except for the true mode above, every failed estimate from knn method also failed from KDE. Then KDE failed on some more.
```{r}
Far_dist_KDE_VC <- Far_distance_VC %>% 
  filter(Method == "KDE")
Far_dist_Inv_dist_VC <- Far_distance_VC %>% 
  filter(Method == "Inverse Distance")
Far_dist_stat_dist_VC <- Far_distance_VC %>% 
  filter(Method == "Stationary Distribution")
# True modes close to other true mode is harder to find
mu_dist_to_nn_VC <- kNNdist(mu_VC, k = 1)
ggplot(data = NULL) +
  geom_density(aes(x = mu_dist_to_nn_VC)) +
  geom_density(aes(x = mu_dist_to_nn_VC[Far_dist_KDE_VC$ID], col = Method), color = "red") +
  geom_density(aes(x = mu_dist_to_nn_VC[Far_dist_Inv_dist_VC$ID], col = Method), color = "blue") +
  geom_density(aes(x = mu_dist_to_nn_VC[Far_dist_stat_dist_VC$ID], col = Method), color = "green") +
  labs(title = "Distribution of smallest distance between true modes (Bad Estimated Modes)", x = "Distance of true mode to nearest other true mode")
#####################################################################
```








----------------------------------------------------------------------
Mostly some test Data


Plot all data from the gaussians where the estimated mode is really bad
```{r}
#All bad clusters
GMM_coordinates_VC %>% 
  as_tibble() %>% 
  mutate(Gaussian = as.factor(sample_vec)) %>% 
  filter(Gaussian %in% Far_distance_VC$ID) %>% 
  ggplot(aes(x = V1, y = V2, col = Gaussian)) +
  geom_point() +
  guides(col = "none")

#Those all methods failed with
All_bad_clust <- GMM_coordinates_VC %>% 
  as_tibble() %>% 
  mutate(Gaussian = as.factor(sample_vec)) %>% 
  filter(Gaussian %in% Far_dist_Inv_dist_VC$ID[-1])

GMM_coordinates_VC %>% 
  as_tibble() %>% 
  ggplot(aes(x = V1, y = V2)) +
  geom_density_2d_filled(aes(x = V1, y = V2), contour_var = 'ndensity') +
  geom_point(data = All_bad_clust, aes(x = V1, y = V2), color = "black", size = 2) +
  guides(col = "none")


```