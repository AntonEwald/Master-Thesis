---
title: "New Tests"
author: "Anton Holm"
date: '2022-03-25'
output: html_document
---



```{r}
source("full_method.R")
```

```{r}
source("Full_Method_Updated.R")

cluster_peaks <- findClusterPeaks(data_c250$Coordinates, avgPeakDist = avg_mode_dist, k = 7, estimator = 2)
```
Now fix the grid loop for calculating delta faster
We will not calculate the edges. This is fine since these are wrong anyways since the images potentially does not include many of its neighbors.


Grid loop for analysis.
Functional one in scripts (for manual cluster detection)
Below is testing for automatic decisions
```{r}
data_c250 <- readRDS("DE (250K genes, varying cellsize + cellshape)//(DATA) n = 57.000, c = 250, tissue = 400, VS.rdata")
############# Find average length between clusters #####################
daata <- data_c250
mode_distances <- dista(daata$Mu, daata$Mu)
diag(mode_distances) <- NA
avg_mode_dist <- mean(apply(mode_distances, 1, min, na.rm = TRUE))
L <- 3*avg_mode_dist
#######################################################################

rho = calc_rho(daata$Coordinates, k=7, estimator = 2)
#Order by rho
sorted_rho <- cbind(daata$Coordinates, rho, 1:length(rho)) %>% 
  .[order(.[,3], decreasing = TRUE), ]
sorted <- cbind(1:length(rho), sorted_rho)
xmin <- min(daata$Coordinates[,1])
xmax <- max(daata$Coordinates[,1])
ymin <- min(daata$Coordinates[,2])
ymax <- max(daata$Coordinates[,2])
xlength <- xmax - xmin
ylength <- ymax - ymin
grid_size <- L/3
xgrids <- ceiling(xlength/grid_size)
ygrids <- ceiling(ylength/grid_size)
deltas <- c()
cluster_centers <- c()
for (i in 2:(ygrids-1)){
  for (j in 2:(xgrids-1)){
    
    large_grid <- sorted[sorted[, 2] < xmin + (j+1)*grid_size &
                       sorted[, 2] >= xmin + (j-2)*grid_size & 
                     sorted[, 3] < ymin + (i+1)*grid_size &
                       sorted[, 3] >= ymin + (i-2)*grid_size, ]
      
    small_grid <- sorted[sorted[, 2] < xmin + j*grid_size &
                       sorted[, 2] >= xmin + (j-1)*grid_size & 
                     sorted[, 3] < ymin + i*grid_size &
                       sorted[, 3] >= ymin + (i-1)*grid_size, ]
    
    if(length(small_grid) > 6*5){ #more than 6 points
    #Atleast 6 points in the small grid
      sub_stats <- matrix(NA, ncol = 3, nrow = nrow(small_grid))
    
        #Calculate our deltas for the small grid
      for (k in 1:nrow(small_grid)){ #For every point in the small grid
        
        if (sum(large_grid[,1] < small_grid[k, 1]) > 1){
          delta = min(apply(large_grid[large_grid[,1] < small_grid[k,1], ][,2:3], 1, function(x) sqrt(sum((x-small_grid[k,2:3])^2))))
          deltas[small_grid[k, 5]] <- delta
          sub_stats[k, 1] <- small_grid[k, 5]
          sub_stats[k, 2] <- delta
          sub_stats[k, 3] <- small_grid[k, 4]
        }
        else if (sum(large_grid[,1] < small_grid[k, 1]) == 0){ #There is no point with larger density
          deltas[small_grid[k, 5]] = L #Give max delta

          sub_stats[k, 1] <- small_grid[k, 5] 
          sub_stats[k, 2] <- L 
          sub_stats[k, 3] <- small_grid[k, 4]
        }
        
        else {
          delta = sqrt((large_grid[large_grid[,1] < small_grid[k,1], ][2] - small_grid[k,2])^2 + (large_grid[large_grid[,1] < small_grid[k,1], ][3] - small_grid[k,3])^2)
          deltas[small_grid[k,5]] <- delta
          sub_stats[k, 1] <-small_grid[k, 5]
          sub_stats[k, 2] <- delta
          sub_stats[k, 3] <- small_grid[k, 4]

        }
      }
      #Here we should check for density peaks
      cluster_centers <- c(cluster_centers, auto_peak_finder(sub_stats))
    }
  }
  print(i)
}


ggplot(data = NULL) +
  geom_point(aes(x = daata$Coordinates[,1], y = daata$Coordinates[,2], col = daata$Samples)) +
  geom_point(aes(x = daata$Coordinates[cluster_centers,1], y = daata$Coordinates[cluster_centers,2]), color = "red", size = 2) +
  geom_point(aes(x = daata$Coordinates[center_id, 1], y = daata$Coordinates[center_id, 2]), color = "green", size = 1) +
  #geom_point(aes(x = daata$Coordinates[small_grid[,5],1], y = daata$Coordinates[small_grid[,5],2]), color = "purple", size = 3) +
  geom_vline(xintercept = xmin + 0:xgrids*grid_size) +
  geom_hline(yintercept = ymin+ 0:ygrids*grid_size) +
  guides(col = "none")

```


Function without derivatives that find the cluster centers based on "counts" of occurance of nr of clusters, i.e. length of a bar. Should fix so that we use derivatives with some smoothing. Smoothing is needed since what is we have 100 ones, 5 twos, 5 threes, 99 fours, 99 fives, 5 sixes, 5 sevens and so on. Then we should pick 4 or 5 clusters, not just 1. 
```{r}
auto_peak_finder <- function(sub_stats){
delta = sub_stats[,2]
  rho = sub_stats[,3]
indicator = c(rep(1, floor(length(delta)*0.1)), rep(0, length(delta) - floor(length(delta)*0.1)))
  iso <- as.stepfun(isoreg(x = log(rho), y = -log(delta))) #monotonic regression line (minus on y cause we have decreasing correlation)
  a = -iso(log(rho)) # Minus again to revert back the minus above
  #Find which constant to use for the decision line ln(rho) + a*ln(delta) = const
  threshold <-  seq(exp(- min(a)), exp(log(L/3) - a[length(a)-(which.max(delta*indicator)-1)]), length.out = 30) 
  clusters <- c()
  
  for (i in 1:length(threshold)){
    clusters[i] <- sum((delta) > (exp(a)*threshold[i]))
  }
  if (length(unique(clusters)) == 1){
    nr_clusters = clusters[1]
  }
  else {
nr_clusters <- sort(table(clusters), decreasing = TRUE) %>% 
  as.data.frame() %>% 
  mutate(clusters = as.numeric(as.character(clusters))) %>% 
  filter(Freq == max(Freq)) %>% .[,1] %>% max() #Cluster with most occurence
}
# Add derivative automation instead
  
stuffs <- cbind(threshold, clusters) 
chosen_thresh <- median(stuffs[stuffs[,2] == nr_clusters, 1]) #Take the threshold in the middle of the peak and valley
peak_id <- sub_stats[which(delta > (exp(a)*chosen_thresh)), 1] #Datapoint ID for cluster centers
return(peak_id)
}
```


























Below is for testing how monotonic regression works in decision graph
Also used to try and automate threshold decision.
Here I need to decide on how to fix min and max of threshold.
```{r}
rho = c(sub_stats[,3])
delta = c(sub_stats[,2])

iso <- as.stepfun(isoreg(x = log(rho), y = -log(delta)))
plot(iso)
a = -iso(log(rho))
b = lm(log(delta)~log(rho))$coefficient[[2]]
# Some analysis on what threshold to pick
y <- exp(a+0)*2.86
y5 <- exp(a)*4
y4 <- exp(a)*5
y2 <- exp(a)*6.3 
y3 <- exp(a)*7.5
y6 <- exp(a)*exp(log(L/3) - min(a))

z <- rho^(b) +1
z5 <- rho^(b) + 3
z4 <- rho^(b) +6
z2 <- rho^(b) +9
z3 <- rho^(b) +14
z6 <- rho^(b) +18

ggplot(data = NULL) +
  geom_point(aes(log(rho), (delta))) +
  geom_line(aes(log(rho), y), color = "yellow") +
      geom_line(aes(log(rho), y5), color = "orange")+
      geom_line(aes(log(rho), y4), color = "red")   +
geom_line(aes(log(rho), y2), color = "light blue") +
      geom_line(aes(log(rho), y3), color = "blue")+
      geom_line(aes(log(rho), y6), color = "purple")

ggplot(data = NULL) +
  geom_point(aes((rho), (delta))) +
  geom_line(aes((rho), z), color = "yellow") +
      geom_line(aes((rho), z5), color = "orange")+
      geom_line(aes((rho), z4), color = "red")   +
geom_line(aes((rho), z2), color = "light blue") +
      geom_line(aes((rho), z3), color = "blue")+
      geom_line(aes((rho), z6), color = "purple")

plot(rho, (delta))

ggplot(data = NULL) +
  geom_point(aes(log(rho), (delta))) +
  geom_hline(yintercept = exp(0 + seq(0.1, log(L), by = 0.1)))

daata$Coordinates %>% as_tibble() %>% 
  rowid_to_column() %>% 
  filter(V2 < 140 & V2 > 120 & V1 > xmin & V1 < 30 ) %>% 
  mutate(rho = cluster_peaks$rho[rowid]) %>% ggplot(aes(x = V1, y = V2, col = rho)) +
  geom_point() +
  xlim(xmin, xmax) +
  ylim(ymin, ymax) +
  geom_vline(xintercept = xmin + 0:2*grid_size)
```
























Below is the findcenter function but there is a better one in scripts (for using derivatives)
```{r}
findCenters <- function(sub_stats){
delta_sub = sub_stats[,2]
rho_sub = sub_stats[,3]
a <- lm(log(delta_sub)~log(rho_sub))$coefficient[[2]]
  #Find which constant to use for the decision line ln(rho) + a*ln(delta) = const
  threshold <-  seq(0, 1, by = 0.001)
  clusters <- c()
  
  for (i in 1:length(threshold)){
    clusters[i] <- sum(delta_sub > (threshold[i]*rho_sub)^a)
  }
library(pracma)
  #Project decisiongraph on regression line to find peaks and valleys
  b <- lm(clusters ~ threshold)$coefficient[[2]]
  new_coefs <- cbind(as.numeric(threshold), as.numeric(clusters - threshold*b))
  #Find all peaks and valleys
  p <- findpeaks(new_coefs[,2])
  v <- findpeaks(-new_coefs[,2])
  #Find the best candidate for threshold
  #If we start with a valley remove it for easier computation (only interested in peak vs next valley)
  if (p[1,2] > v[1,2]| length(p) == 0) {
    p = rbind(c(0, 1, 0, 0), p)
  }
  #Add a minimum at the end if the curve was still going down
  
  if (nrow(p) > nrow(v)){
    v = rbind(v, c(0, length(threshold), 0, 0))
  }
  ind_pv <- which.max(v[, 2] - p[, 2])
  ind_bin <- (p[ind_pv, 2] + v[ind_pv,2])/2
  Threshold <- stats$coefs[[ind_bin, 1]]
  #Threshold found
  center_id = sub_stats[which(delta > (Threshold*rho)^a),1]
  return(center_id = center_id)
}

```










 - 